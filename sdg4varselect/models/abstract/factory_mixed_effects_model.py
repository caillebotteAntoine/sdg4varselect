"""

Create by antoine.caillebotte@inrae.fr
"""

# pylint: disable=missing-return-doc, missing-function-docstring

import functools

import jax.numpy as jnp
from jax import jit
import jax.random as jrd


import parametrization_cookbook.jax as pc

from sdg4varselect.models.abstract.abstract_mixed_effects_model import (
    AbstractMixedEffectsModel,
)

from sdg4varselect.models.abstract.abstract_high_dim_model import (
    AbstractHDModel,
)
from sdg4varselect._doc_tools import inherit_docstring
import sdg4varselect.plotting as sdgplt

MEM_FACTORY_DOC = """Mixed-effects model class generated by FactoryMixedEffectsModel.

        This class represents a nonlinear mixed-effects model of the form:

            Y = m(t, φ) + ε

        where:
            - m(t, φ): structural model function (user-specified)
            - φ: individual parameters (latent variables)
            - ε: residual noise term

        """


def factory_mixed_effects_model(spec):
    """Factory function to create a Mixed-Effects Model class.

    This function accepts a single spec dictionary with the following keys:
        - name: callable
            Function that takes a dictionary of attributes and returns the name of the model.
        - parametrization: callable
            Function that takes a dictionary of attributes and returns the parametrization of the model.
        - individual_parameters_names: list of str
            List of names of individual parameters (latent variables).
        - structural_model: callable
            Function representing the structural model m(t, φ).
        - individual_parameters: callable
            Function to compute individual parameters φ from the model instance and parameters.
        - highdim: bool, optional
            If True, the generated class will also inherit from AbstractHDModel.

    Parameters
    ----------
    spec : dict
        Specification dictionary defining the mixed-effects model.

    Returns
    -------
    class
        A Mixed-Effects Model class.
    """
    name = spec["name"]
    parametrization = spec["parametrization"]
    individual_parameters_names = spec["individual_parameters_names"]
    structural_model = spec["structural_model"]
    individual_parameters = spec["individual_parameters"]
    highdim = spec.get("highdim", False)

    @inherit_docstring
    class X(AbstractMixedEffectsModel):
        __doc__ = MEM_FACTORY_DOC

        def __init__(self, **kwargs):
            AbstractMixedEffectsModel.__init__(self, **kwargs)

            for vname in individual_parameters_names:
                self.add_latent_variables(vname)

        @property
        def name(self) -> str:
            return name(self.__dict__)

        # ============================================================== #
        def init_parametrization(self):
            self._parametrization = parametrization(self.__dict__)

        # ============================================================== #
        @functools.partial(jit, static_argnums=0)
        def mixed_effect_function(self, params, *args, **kwargs) -> jnp.ndarray:
            return structural_model(params, *args, **kwargs)

        # ============================================================== #
        @functools.partial(jit, static_argnums=0)
        def get_mean_latent(self, params, **kwargs) -> jnp.ndarray:
            return individual_parameters(self, params, **kwargs)

        # ============================================================== #

        def sample(self, params_star, prngkey, **kwargs) -> tuple[dict, jnp.ndarray]:
            mem_obs_time = kwargs.get("mem_obs_time")

            obs, sim = AbstractMixedEffectsModel.sample(
                self, params_star, prngkey, **kwargs
            )

            return {"mem_obs_time": mem_obs_time} | obs, sim

    if highdim:

        @inherit_docstring
        class Y(X, AbstractHDModel):
            __doc__ = MEM_FACTORY_DOC

            def __init__(self, **kwargs):
                AbstractHDModel.__init__(self, P=kwargs.get("P"))
                X.__init__(self, **kwargs)

        return Y

    return X


if __name__ == "__main__":

    def m(  # pylint: disable=C0103, unused-argument
        params, times, **kwargs
    ) -> jnp.ndarray:
        D = kwargs.get("D")
        V = kwargs.get("V")
        ka = kwargs.get("ka")
        Cl = kwargs.get("Cl")
        out = (
            D
            * ka[:, None]
            / (V * ka[:, None] - Cl[:, None])
            * (jnp.exp(-Cl[:, None] / V * times) - jnp.exp(-ka[:, None] * times))
        )

        print(out.shape, times.shape)

        assert out.shape == times.shape
        return out

    def mixed_effects(  # pylint: disable=unused-argument
        self, params, **kwargs
    ) -> jnp.ndarray:
        return jnp.array([params.mean_latent.mu1, params.mean_latent.mu2])

    PKMixedEffectsModel = factory_mixed_effects_model(
        {
            "name": lambda x: f"FactoryMixedEffectsModel_{x}",
            "parametrization": lambda x: pc.NamedTuple(
                mean_latent=pc.NamedTuple(
                    mu1=pc.Real(loc=10, scale=1),
                    mu2=pc.Real(loc=10, scale=1),
                ),
                cov_latent=pc.MatrixDiagPosDef(dim=2, scale=1),
                var_residual=pc.RealPositive(scale=0.01),
            ),
            "individual_parameters_names": ["ka", "Cl"],
            "structural_model": m,
            "individual_parameters": mixed_effects,
        }
    )

    myModel = PKMixedEffectsModel(N=50, J=12, D=100, V=30)

    p_star = myModel.new_params(
        mean_latent={"mu1": 6, "mu2": 8},
        cov_latent=jnp.diag(jnp.array([0.2, 0.1])),
        var_residual=1e-3,
    )

    time = jnp.array([0.05, 0.15, 0.25, 0.4, 0.5, 0.8, 1, 2, 7, 12, 24, 40])
    time = jnp.tile(time, (myModel.N, 1))

    myobs, mysim = myModel.sample(
        p_star,
        jrd.PRNGKey(0),
        mem_obs_time=time,
    )
    ax = sdgplt.ax(4, 7)
    _ = ax.plot(myobs["mem_obs_time"].T, myobs["Y"].T, "o-")
